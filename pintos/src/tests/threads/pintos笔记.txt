1 priority_donate_one解决一部分方法之一:将sema_down函数的 list_push_back (&sema->waiters, &thread_current ()->elem)改为  list_insert_ordered(&sema->waiters,&thread_current()->elem,(list_less_func *) &thread_cmp_priority,NULL);保证在lock_acquire后，让线程按优先级从大到小排列进入睡眠中，
 而在lock_realse()函数后，释放锁，这时候从sema->waiter这个链表中找到优先级最大的线程，获得CPU，然后现在只剩如何在lock_acquire后，如何让main的优先级提高
	-20190601

2 priority-donate_multiple:如何知道有几个锁，我的思路是
				在struct thread里加入一个number_lock，在thread_create里初始化为0
				然后lock_acuqire()里thread_current()->number_lock++;
				在lock_realese里执行thread_current()->number_lock--;
				核心操作:建立一个链表，用插入list_push_back的方式，比如说刚开始在
				thread_create里这个链表里只有原来的prioriity，在priority-donate-mulitple程				序中，
3 第2无效,分析priority-donate-multiple,priority-donate-multiple2,priority-donate-nest.c等:thread_create中的参数aux可以为任何类型，不单单为struct lock 类型
	  第三，当main线程没有获得锁的时候，需要在thread_create中实现线程调度功能，但怎么实现，要仔细思考
   如何实现:在main没有获得锁的时候，thread_create创造线程a,完成线程a和main的切换，如果a的优先级x大于main的优先级y，我们让a得到cpu,并且把main的优先级变得跟a一样，即我们让main的优先级变大了,从x变成y，,而且a执行完毕后，我们让main的优先级从y重新变回x，
           如果main获得了锁，即执行了lock_acquire函数，在执行lock_release()函数之前，都是main获得cpu,如果thread_create函数创造了线程b，其优先级为z,如果z > y;y是main的优先级，则此时main的优先级从y变为z,main释放锁后，如果main还没有执行完毕，则将main悬挂，然后b获得CPU，b执行完毕后，main的线程重新有z变回y
	  
